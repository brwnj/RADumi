#!/usr/bin/env python
# encoding: utf-8
"""
Finding unique restriction site associated DNA (RAD) tag sequences per unique
molecular identifier (UMI).
"""
import sys
from toolshed import nopen
from itertools import islice, groupby, izip

IUPAC = {"A":"A","T":"T","C":"C","G":"G","R":"GA","Y":"TC",
         "M":"AC","K":"GT","S":"GC","W":"AT","H":"ACT",
         "B":"GTC","V":"GCA","D":"GAT","N":"GATC"}

def read_fastq(fh):
    """fastq parser that returns name, seq, and qual."""
    while True:
        values = list(islice(fh, 4))
        if len(values) == 4:
            id1, seq, id2, qual = values
        elif len(values) == 0:
            raise StopIteration
        else:
            raise EOFError("unexpected end of file")
        assert id1.startswith('@')
        assert id2.startswith('+')
        assert len(seq) == len(qual)
        yield id1[1:-1], seq[:-1], qual[:-1]

def read_fasta(fa):
    """parses fasta filehandle and returns name and sequence."""
    for header, group in groupby(fa, lambda line: line[0] == '>'):
        if header:
            line = group.next()
            name = line[1:].strip()
        else:
            seq = ''.join(line.strip() for line in group)
            yield name, seq

def valid_umi(iupac, umi):
    """parse UMI sequence to validate against IUPAC sequence."""
    for code, base in izip(iupac, umi):
        try:
            if not base in IUPAC[code]:
                return False
        except KeyError:
            return False
    return True

def run_dump(args):
    """fastq, umi, position"""
    with nopen(args.fastq) as fh:
        for name, seq, qual in read_fastq(fh):
            umi = seq[:args.length]
            print ">%s\n%s" % (name.split()[0], umi)

def fasta_to_dict(fasta):
    """docstring for fasta_to_dict"""
    d = {}
    with nopen(fasta) as fh:
        for name, seq in read_fasta(fh):
            # should no longer need to split here
            d[name.split()[0]] = seq
    return d

def run_add(args):
    """fastq, fasta"""
    umi_d = fasta_to_dict(args.fasta)
    umi_qual = ']' * len(umi_d[umi_d.keys()[0]])
    with nopen(args.fastq) as fh:
        for name, seq, qual in read_fastq(fh):
            try:
                umi = umi_d[name.split()[0]]
                assert len(umi) == len(umi_qual)
            except KeyError:
                # read not present in R1; flag with invalid UMI
                umi = 'X' * len(umi_qual)
            print "@%s\n%s%s\n+\n%s%s" % (name, umi, seq, umi_qual, qual)

def run_sort(args):
    """fastq, length"""
    if args.fastq.endswith(".gz"):
        cmd = "| gunzip -c %s | " % args.fastq
    else:
        cmd = "| zcat %s | " % args.fastq
    cmd += """awk '{ printf($0); n++; if(n%4==0){ printf("\\n") } else { printf("\\t") } }' | \
                awk '{ i=substr($2,1,8); print i"\\t"$0 }' | \
                sort -k1,1 | \
                cut -f 2,3,4,5 | \
                tr "\\t" "\\n\""""
    print "".join([line for line in nopen(cmd)])

def run_scan(args):
    """fastq, umi, five, three"""
    #"@%s\n%s\n+\n%s" % (name, seq[leng:], qual[leng:])
    
    leng = len(args.umi)
    with nopen(args.fastq) as fh:
        fqiter = read_fastq(fh)
        for name, seq, qual in fqiter:
            umiseq = seq[:leng]
            
            # testing
            if umiseq == "AAAAAAAG":
                sys.exit()
            # skip anything with an invalid UMI
            if not valid_umi(args.umi, umiseq): continue
            for match, group in groupby(fqiter, lambda (n,s,q): s[:leng] == umiseq):
                if match:
                    # compile all the reads of this UMI using
                    # g is an iterable of name, seq, qual
                    for name, seq, qual in group:
                        print seq
                break

def main(args):
    args.func(args)

if __name__ == "__main__":
    import argparse
    p = argparse.ArgumentParser(description=__doc__,
            formatter_class=argparse.RawDescriptionHelpFormatter)
    subp = p.add_subparsers(help='commands')

    # dump UMI sequence from R1 into fasta
    fdump = subp.add_parser('dump', description="Prints fasta of read name and 5' UMI sequence.",
            help="obtain fasta of read name and 5' UMI sequence")
    fdump.add_argument('fastq', metavar="FASTQ", help="fastq containing a UMI")
    fdump.add_argument('length', metavar="LENGTH", help="length of the UMI sequence")
    fdump.set_defaults(func=run_dump)

    # attach UMI of R1 onto R2 for identification
    fadd = subp.add_parser('add', description="Add UMI of dumped FASTA onto matched read name of FASTQ on the 5' end. Quality of the UMI will be ']'.",
            help="add 5' UMI from dumped fasta onto reads of FASTQ")
    fadd.add_argument('fastq', metavar="FASTQ", help="reads onto which to add the UMI")
    fadd.add_argument('fasta', metavar="FASTA", help="dumped UMI sequences")
    fadd.set_defaults(func=run_add)

    # sorting the fastq by umi
    fsort = subp.add_parser('sort', description="Sorts fastq by UMI.",
            help="order the fastq by the UMI to facilitate processing")
    fsort.add_argument('fastq', metavar='FASTQ',
            help='unsorted reads with incorporated UMI')
    fsort.add_argument('length', metavar='LENGTH',
            help='length of the UMI sequence')
    fsort.set_defaults(func=run_sort)
    
    # find most abundance sequence per umi
    fscan = subp.add_parser('scan', description="Finds most abundant sequence per valid UMI.",
            help="find most abundant sequence per UMI")
    fscan.add_argument('fastq', metavar="FASTQ", help="reads with UMI to scan")
    fscan.add_argument('umi', metavar="UMI", help='IUPAC sequence of the UMI, e.g. NNNNNV')
    fscan.add_argument('-5', dest='five', type=int, default=0, help="number of 5' bases to trim AFTER the UMI sequence [ %(default)s ]")
    fscan.add_argument('-3', dest='three', type=int, default=0, help="number of 3' bases to trim [ %(default)s ]")
    fscan.set_defaults(func=run_scan)
    
    main(p.parse_args())