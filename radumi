#!/usr/bin/env python
# encoding: utf-8
"""
Finding unique restriction site associated DNA (RAD) tag sequences per unique
molecular identifier (UMI).
"""
import sys
from toolshed import nopen
from itertools import islice, groupby, izip

IUPAC = {"A":"A","T":"T","C":"C","G":"G","R":"GA","Y":"TC",
         "M":"AC","K":"GT","S":"GC","W":"AT","H":"ACT",
         "B":"GTC","V":"GCA","D":"GAT","N":"GATC"}

def read_fastq(fh):
    """fastq parser that returns name, seq, and qual."""
    while True:
        values = list(islice(fh, 4))
        if len(values) == 4:
            id1, seq, id2, qual = values
        elif len(values) == 0:
            raise StopIteration
        else:
            raise EOFError("unexpected end of file")
        assert id1.startswith('@')
        assert id2.startswith('+')
        assert len(seq) == len(qual)
        yield id1[1:-1], seq[:-1], qual[:-1]

def read_fasta(fa):
    """parses fasta filehandle and returns name and sequence."""
    for header, group in groupby(fa, lambda line: line[0] == '>'):
        if header:
            line = group.next()
            name = line[1:].strip()
        else:
            seq = ''.join(line.strip() for line in group)
            yield name, seq

def valid_umi(iupac, umi):
    """parse UMI sequence to validate against IUPAC sequence."""
    for code, base in izip(iupac, umi):
        try:
            if not base in IUPAC[code]:
                return False
        except KeyError:
            return False
    return True

def run_dump(args):
    """fastq, umi, position"""
    # could just pass the length of the UMI and the position,
    # but later I may want the quality
    leng = len(args.umi)
    with nopen(args.fastq) as fastq:
        for name, seq, qual in read_fastq(fastq):
            umi = seq[:leng] if args.position == "5" else seq[-leng:]
            print ">%s\n%s" % (name.split()[0], umi)

def fasta_to_dict(fasta):
    """docstring for fasta_to_dict"""
    d = {}
    with nopen(fasta) as fh:
        for name, seq in read_fasta(fh):
            # should no longer need to split here
            d[name.split()[0]] = seq
    return d

def run_addumi(args):
    """fastq, fasta"""
    umi_d = fasta_to_dict(args.fasta)
    umi_qual = ']' * len(umi_d[umi_d.keys()[0]])
    with nopen(args.fastq) as fastq:
        for name, seq, qual in read_fastq(fastq):
            try:
                umi = umi_d[name.split()[0]]
                assert len(umi) == len(umi_qual)
            except KeyError:
                # read not present in R1; flag with invalid UMI
                umi = 'X' * len(umi_qual)
            print "@%s\n%s%s\n+\n%s%s" % (name, umi, seq, umi_qual, qual)

def run_sort(args):
    """fastq, length"""
    if args.fastq.endswith(".gz"):
        cmd = "| gunzip -c %s | " % args.fastq
    else:
        cmd = "| zcat %s | " % args.fastq
    cmd += """awk '{ printf($0); n++; if(n%4==0){ printf("\\n") } else { printf("\\t") } }' | \
                awk '{ i=substr($2,1,8); print i"\\t"$0 }' | \
                sort -k1,1 | \
                cut -f 2,3,4,5 | \
                tr "\\t" "\\n\""""
    print "".join([line for line in nopen(cmd)])

def main(args):
    # take most abundant sequence for each UMI using a Counter
        # this would likely be a fasta...
    args.func(args)

if __name__ == "__main__":
    import argparse
    p = argparse.ArgumentParser(description=__doc__,
            formatter_class=argparse.RawDescriptionHelpFormatter)
    subp = p.add_subparsers(help='commands')

    # dump UMI sequence from R1 into fasta
    fdump = subp.add_parser('dump', description="Prints fasta of read name and UMI sequence. No UMI-based filtering occurs.",
            help="if R2 has no UMI, use this to later add R1 UMI to the correct R2 read")
    fdump.add_argument('fastq', metavar="FASTQ", help="fastq containing a UMI")
    fdump.add_argument('umi', metavar="UMI", help="IUPAC UMI sequence, e.g. NNNNNV")
    fdump.add_argument('--position', choices=['5', '3'], default='5', help="UMI location on the read [ %(default)s ]")
    fdump.set_defaults(func=run_dump)

    # attach UMI of R1 onto R2 for identification
    faddumi = subp.add_parser('addumi', description="Add UMI of dumped fasta onto matched read name of fastq on the 5' end. Fastq quality of the UMI will be ']'",
            help="add 5' UMI from dumped fasta onto reads of fastq")
    faddumi.add_argument('fastq', metavar="FASTQ", help="reads onto which to add the UMI")
    faddumi.add_argument('fasta', metavar="FASTA", help="dumped UMI sequences")
    faddumi.set_defaults(func=run_addumi)

    # sorting the fastq by umi
    fsort = subp.add_parser('sort', description="Sorts fastq by UMI. Prints sorted fastq to stdout.",
            help="order the fastq by the UMI to facilitate processing")
    fsort.add_argument('fastq', metavar='FASTQ',
            help='unsorted reads with incorporated UMI')
    fsort.add_argument('length', metavar='LENGTH',
            help='length of the UMI sequence')
    fsort.set_defaults(func=run_sort)
    main(p.parse_args())